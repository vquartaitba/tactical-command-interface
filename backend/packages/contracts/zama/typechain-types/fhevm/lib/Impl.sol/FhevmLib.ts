/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  PopulatedTransaction,
  Signer,
  utils,
} from "ethers";
import type { FunctionFragment, Result } from "@ethersproject/abi";
import type { Listener, Provider } from "@ethersproject/providers";
import type {
  TypedEventFilter,
  TypedEvent,
  TypedListener,
  OnEvent,
  PromiseOrValue,
} from "../../../common";

export interface FhevmLibInterface extends utils.Interface {
  functions: {
    "cast(uint256,bytes1)": FunctionFragment;
    "decrypt(uint256)": FunctionFragment;
    "fheAdd(uint256,uint256,bytes1)": FunctionFragment;
    "fheArrayEq(uint256[],uint256[])": FunctionFragment;
    "fheBitAnd(uint256,uint256,bytes1)": FunctionFragment;
    "fheBitOr(uint256,uint256,bytes1)": FunctionFragment;
    "fheBitXor(uint256,uint256,bytes1)": FunctionFragment;
    "fheDiv(uint256,uint256,bytes1)": FunctionFragment;
    "fheEq(uint256,uint256,bytes1)": FunctionFragment;
    "fheGe(uint256,uint256,bytes1)": FunctionFragment;
    "fheGt(uint256,uint256,bytes1)": FunctionFragment;
    "fheIfThenElse(uint256,uint256,uint256)": FunctionFragment;
    "fheLe(uint256,uint256,bytes1)": FunctionFragment;
    "fheLt(uint256,uint256,bytes1)": FunctionFragment;
    "fheMax(uint256,uint256,bytes1)": FunctionFragment;
    "fheMin(uint256,uint256,bytes1)": FunctionFragment;
    "fheMul(uint256,uint256,bytes1)": FunctionFragment;
    "fheNe(uint256,uint256,bytes1)": FunctionFragment;
    "fheNeg(uint256)": FunctionFragment;
    "fheNot(uint256)": FunctionFragment;
    "fhePubKey(bytes1)": FunctionFragment;
    "fheRand(bytes1)": FunctionFragment;
    "fheRandBounded(uint256,bytes1)": FunctionFragment;
    "fheRem(uint256,uint256,bytes1)": FunctionFragment;
    "fheRotl(uint256,uint256,bytes1)": FunctionFragment;
    "fheRotr(uint256,uint256,bytes1)": FunctionFragment;
    "fheShl(uint256,uint256,bytes1)": FunctionFragment;
    "fheShr(uint256,uint256,bytes1)": FunctionFragment;
    "fheSub(uint256,uint256,bytes1)": FunctionFragment;
    "reencrypt(uint256,uint256)": FunctionFragment;
    "trivialEncrypt(uint256,bytes1)": FunctionFragment;
    "verifyCiphertext(bytes)": FunctionFragment;
  };

  getFunction(
    nameOrSignatureOrTopic:
      | "cast"
      | "decrypt"
      | "fheAdd"
      | "fheArrayEq"
      | "fheBitAnd"
      | "fheBitOr"
      | "fheBitXor"
      | "fheDiv"
      | "fheEq"
      | "fheGe"
      | "fheGt"
      | "fheIfThenElse"
      | "fheLe"
      | "fheLt"
      | "fheMax"
      | "fheMin"
      | "fheMul"
      | "fheNe"
      | "fheNeg"
      | "fheNot"
      | "fhePubKey"
      | "fheRand"
      | "fheRandBounded"
      | "fheRem"
      | "fheRotl"
      | "fheRotr"
      | "fheShl"
      | "fheShr"
      | "fheSub"
      | "reencrypt"
      | "trivialEncrypt"
      | "verifyCiphertext"
  ): FunctionFragment;

  encodeFunctionData(
    functionFragment: "cast",
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<BytesLike>]
  ): string;
  encodeFunctionData(
    functionFragment: "decrypt",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "fheAdd",
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BytesLike>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "fheArrayEq",
    values: [PromiseOrValue<BigNumberish>[], PromiseOrValue<BigNumberish>[]]
  ): string;
  encodeFunctionData(
    functionFragment: "fheBitAnd",
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BytesLike>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "fheBitOr",
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BytesLike>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "fheBitXor",
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BytesLike>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "fheDiv",
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BytesLike>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "fheEq",
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BytesLike>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "fheGe",
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BytesLike>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "fheGt",
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BytesLike>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "fheIfThenElse",
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "fheLe",
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BytesLike>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "fheLt",
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BytesLike>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "fheMax",
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BytesLike>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "fheMin",
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BytesLike>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "fheMul",
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BytesLike>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "fheNe",
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BytesLike>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "fheNeg",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "fheNot",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "fhePubKey",
    values: [PromiseOrValue<BytesLike>]
  ): string;
  encodeFunctionData(
    functionFragment: "fheRand",
    values: [PromiseOrValue<BytesLike>]
  ): string;
  encodeFunctionData(
    functionFragment: "fheRandBounded",
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<BytesLike>]
  ): string;
  encodeFunctionData(
    functionFragment: "fheRem",
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BytesLike>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "fheRotl",
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BytesLike>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "fheRotr",
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BytesLike>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "fheShl",
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BytesLike>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "fheShr",
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BytesLike>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "fheSub",
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BytesLike>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "reencrypt",
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "trivialEncrypt",
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<BytesLike>]
  ): string;
  encodeFunctionData(
    functionFragment: "verifyCiphertext",
    values: [PromiseOrValue<BytesLike>]
  ): string;

  decodeFunctionResult(functionFragment: "cast", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "decrypt", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "fheAdd", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "fheArrayEq", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "fheBitAnd", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "fheBitOr", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "fheBitXor", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "fheDiv", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "fheEq", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "fheGe", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "fheGt", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "fheIfThenElse",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "fheLe", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "fheLt", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "fheMax", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "fheMin", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "fheMul", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "fheNe", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "fheNeg", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "fheNot", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "fhePubKey", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "fheRand", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "fheRandBounded",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "fheRem", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "fheRotl", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "fheRotr", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "fheShl", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "fheShr", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "fheSub", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "reencrypt", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "trivialEncrypt",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "verifyCiphertext",
    data: BytesLike
  ): Result;

  events: {};
}

export interface FhevmLib extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: FhevmLibInterface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(
    eventFilter?: TypedEventFilter<TEvent>
  ): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(
    eventFilter: TypedEventFilter<TEvent>
  ): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    cast(
      ct: PromiseOrValue<BigNumberish>,
      toType: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { result: BigNumber }>;

    decrypt(
      ct: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { result: BigNumber }>;

    fheAdd(
      lhs: PromiseOrValue<BigNumberish>,
      rhs: PromiseOrValue<BigNumberish>,
      scalarByte: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { result: BigNumber }>;

    fheArrayEq(
      lhs: PromiseOrValue<BigNumberish>[],
      rhs: PromiseOrValue<BigNumberish>[],
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { result: BigNumber }>;

    fheBitAnd(
      lhs: PromiseOrValue<BigNumberish>,
      rhs: PromiseOrValue<BigNumberish>,
      scalarByte: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { result: BigNumber }>;

    fheBitOr(
      lhs: PromiseOrValue<BigNumberish>,
      rhs: PromiseOrValue<BigNumberish>,
      scalarByte: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { result: BigNumber }>;

    fheBitXor(
      lhs: PromiseOrValue<BigNumberish>,
      rhs: PromiseOrValue<BigNumberish>,
      scalarByte: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { result: BigNumber }>;

    fheDiv(
      lhs: PromiseOrValue<BigNumberish>,
      rhs: PromiseOrValue<BigNumberish>,
      scalarByte: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { result: BigNumber }>;

    fheEq(
      lhs: PromiseOrValue<BigNumberish>,
      rhs: PromiseOrValue<BigNumberish>,
      scalarByte: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { result: BigNumber }>;

    fheGe(
      lhs: PromiseOrValue<BigNumberish>,
      rhs: PromiseOrValue<BigNumberish>,
      scalarByte: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { result: BigNumber }>;

    fheGt(
      lhs: PromiseOrValue<BigNumberish>,
      rhs: PromiseOrValue<BigNumberish>,
      scalarByte: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { result: BigNumber }>;

    fheIfThenElse(
      control: PromiseOrValue<BigNumberish>,
      ifTrue: PromiseOrValue<BigNumberish>,
      ifFalse: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { result: BigNumber }>;

    fheLe(
      lhs: PromiseOrValue<BigNumberish>,
      rhs: PromiseOrValue<BigNumberish>,
      scalarByte: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { result: BigNumber }>;

    fheLt(
      lhs: PromiseOrValue<BigNumberish>,
      rhs: PromiseOrValue<BigNumberish>,
      scalarByte: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { result: BigNumber }>;

    fheMax(
      lhs: PromiseOrValue<BigNumberish>,
      rhs: PromiseOrValue<BigNumberish>,
      scalarByte: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { result: BigNumber }>;

    fheMin(
      lhs: PromiseOrValue<BigNumberish>,
      rhs: PromiseOrValue<BigNumberish>,
      scalarByte: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { result: BigNumber }>;

    fheMul(
      lhs: PromiseOrValue<BigNumberish>,
      rhs: PromiseOrValue<BigNumberish>,
      scalarByte: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { result: BigNumber }>;

    fheNe(
      lhs: PromiseOrValue<BigNumberish>,
      rhs: PromiseOrValue<BigNumberish>,
      scalarByte: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { result: BigNumber }>;

    fheNeg(
      ct: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { result: BigNumber }>;

    fheNot(
      ct: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { result: BigNumber }>;

    fhePubKey(
      fromLib: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<[string] & { result: string }>;

    fheRand(
      randType: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { result: BigNumber }>;

    fheRandBounded(
      upperBound: PromiseOrValue<BigNumberish>,
      randType: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { result: BigNumber }>;

    fheRem(
      lhs: PromiseOrValue<BigNumberish>,
      rhs: PromiseOrValue<BigNumberish>,
      scalarByte: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { result: BigNumber }>;

    fheRotl(
      lhs: PromiseOrValue<BigNumberish>,
      rhs: PromiseOrValue<BigNumberish>,
      scalarByte: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { result: BigNumber }>;

    fheRotr(
      lhs: PromiseOrValue<BigNumberish>,
      rhs: PromiseOrValue<BigNumberish>,
      scalarByte: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { result: BigNumber }>;

    fheShl(
      lhs: PromiseOrValue<BigNumberish>,
      rhs: PromiseOrValue<BigNumberish>,
      scalarByte: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { result: BigNumber }>;

    fheShr(
      lhs: PromiseOrValue<BigNumberish>,
      rhs: PromiseOrValue<BigNumberish>,
      scalarByte: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { result: BigNumber }>;

    fheSub(
      lhs: PromiseOrValue<BigNumberish>,
      rhs: PromiseOrValue<BigNumberish>,
      scalarByte: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { result: BigNumber }>;

    reencrypt(
      ct: PromiseOrValue<BigNumberish>,
      publicKey: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[string]>;

    trivialEncrypt(
      ct: PromiseOrValue<BigNumberish>,
      toType: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { result: BigNumber }>;

    verifyCiphertext(
      input: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { result: BigNumber }>;
  };

  cast(
    ct: PromiseOrValue<BigNumberish>,
    toType: PromiseOrValue<BytesLike>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  decrypt(
    ct: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  fheAdd(
    lhs: PromiseOrValue<BigNumberish>,
    rhs: PromiseOrValue<BigNumberish>,
    scalarByte: PromiseOrValue<BytesLike>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  fheArrayEq(
    lhs: PromiseOrValue<BigNumberish>[],
    rhs: PromiseOrValue<BigNumberish>[],
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  fheBitAnd(
    lhs: PromiseOrValue<BigNumberish>,
    rhs: PromiseOrValue<BigNumberish>,
    scalarByte: PromiseOrValue<BytesLike>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  fheBitOr(
    lhs: PromiseOrValue<BigNumberish>,
    rhs: PromiseOrValue<BigNumberish>,
    scalarByte: PromiseOrValue<BytesLike>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  fheBitXor(
    lhs: PromiseOrValue<BigNumberish>,
    rhs: PromiseOrValue<BigNumberish>,
    scalarByte: PromiseOrValue<BytesLike>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  fheDiv(
    lhs: PromiseOrValue<BigNumberish>,
    rhs: PromiseOrValue<BigNumberish>,
    scalarByte: PromiseOrValue<BytesLike>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  fheEq(
    lhs: PromiseOrValue<BigNumberish>,
    rhs: PromiseOrValue<BigNumberish>,
    scalarByte: PromiseOrValue<BytesLike>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  fheGe(
    lhs: PromiseOrValue<BigNumberish>,
    rhs: PromiseOrValue<BigNumberish>,
    scalarByte: PromiseOrValue<BytesLike>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  fheGt(
    lhs: PromiseOrValue<BigNumberish>,
    rhs: PromiseOrValue<BigNumberish>,
    scalarByte: PromiseOrValue<BytesLike>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  fheIfThenElse(
    control: PromiseOrValue<BigNumberish>,
    ifTrue: PromiseOrValue<BigNumberish>,
    ifFalse: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  fheLe(
    lhs: PromiseOrValue<BigNumberish>,
    rhs: PromiseOrValue<BigNumberish>,
    scalarByte: PromiseOrValue<BytesLike>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  fheLt(
    lhs: PromiseOrValue<BigNumberish>,
    rhs: PromiseOrValue<BigNumberish>,
    scalarByte: PromiseOrValue<BytesLike>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  fheMax(
    lhs: PromiseOrValue<BigNumberish>,
    rhs: PromiseOrValue<BigNumberish>,
    scalarByte: PromiseOrValue<BytesLike>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  fheMin(
    lhs: PromiseOrValue<BigNumberish>,
    rhs: PromiseOrValue<BigNumberish>,
    scalarByte: PromiseOrValue<BytesLike>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  fheMul(
    lhs: PromiseOrValue<BigNumberish>,
    rhs: PromiseOrValue<BigNumberish>,
    scalarByte: PromiseOrValue<BytesLike>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  fheNe(
    lhs: PromiseOrValue<BigNumberish>,
    rhs: PromiseOrValue<BigNumberish>,
    scalarByte: PromiseOrValue<BytesLike>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  fheNeg(
    ct: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  fheNot(
    ct: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  fhePubKey(
    fromLib: PromiseOrValue<BytesLike>,
    overrides?: CallOverrides
  ): Promise<string>;

  fheRand(
    randType: PromiseOrValue<BytesLike>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  fheRandBounded(
    upperBound: PromiseOrValue<BigNumberish>,
    randType: PromiseOrValue<BytesLike>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  fheRem(
    lhs: PromiseOrValue<BigNumberish>,
    rhs: PromiseOrValue<BigNumberish>,
    scalarByte: PromiseOrValue<BytesLike>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  fheRotl(
    lhs: PromiseOrValue<BigNumberish>,
    rhs: PromiseOrValue<BigNumberish>,
    scalarByte: PromiseOrValue<BytesLike>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  fheRotr(
    lhs: PromiseOrValue<BigNumberish>,
    rhs: PromiseOrValue<BigNumberish>,
    scalarByte: PromiseOrValue<BytesLike>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  fheShl(
    lhs: PromiseOrValue<BigNumberish>,
    rhs: PromiseOrValue<BigNumberish>,
    scalarByte: PromiseOrValue<BytesLike>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  fheShr(
    lhs: PromiseOrValue<BigNumberish>,
    rhs: PromiseOrValue<BigNumberish>,
    scalarByte: PromiseOrValue<BytesLike>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  fheSub(
    lhs: PromiseOrValue<BigNumberish>,
    rhs: PromiseOrValue<BigNumberish>,
    scalarByte: PromiseOrValue<BytesLike>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  reencrypt(
    ct: PromiseOrValue<BigNumberish>,
    publicKey: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<string>;

  trivialEncrypt(
    ct: PromiseOrValue<BigNumberish>,
    toType: PromiseOrValue<BytesLike>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  verifyCiphertext(
    input: PromiseOrValue<BytesLike>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  callStatic: {
    cast(
      ct: PromiseOrValue<BigNumberish>,
      toType: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    decrypt(
      ct: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    fheAdd(
      lhs: PromiseOrValue<BigNumberish>,
      rhs: PromiseOrValue<BigNumberish>,
      scalarByte: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    fheArrayEq(
      lhs: PromiseOrValue<BigNumberish>[],
      rhs: PromiseOrValue<BigNumberish>[],
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    fheBitAnd(
      lhs: PromiseOrValue<BigNumberish>,
      rhs: PromiseOrValue<BigNumberish>,
      scalarByte: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    fheBitOr(
      lhs: PromiseOrValue<BigNumberish>,
      rhs: PromiseOrValue<BigNumberish>,
      scalarByte: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    fheBitXor(
      lhs: PromiseOrValue<BigNumberish>,
      rhs: PromiseOrValue<BigNumberish>,
      scalarByte: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    fheDiv(
      lhs: PromiseOrValue<BigNumberish>,
      rhs: PromiseOrValue<BigNumberish>,
      scalarByte: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    fheEq(
      lhs: PromiseOrValue<BigNumberish>,
      rhs: PromiseOrValue<BigNumberish>,
      scalarByte: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    fheGe(
      lhs: PromiseOrValue<BigNumberish>,
      rhs: PromiseOrValue<BigNumberish>,
      scalarByte: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    fheGt(
      lhs: PromiseOrValue<BigNumberish>,
      rhs: PromiseOrValue<BigNumberish>,
      scalarByte: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    fheIfThenElse(
      control: PromiseOrValue<BigNumberish>,
      ifTrue: PromiseOrValue<BigNumberish>,
      ifFalse: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    fheLe(
      lhs: PromiseOrValue<BigNumberish>,
      rhs: PromiseOrValue<BigNumberish>,
      scalarByte: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    fheLt(
      lhs: PromiseOrValue<BigNumberish>,
      rhs: PromiseOrValue<BigNumberish>,
      scalarByte: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    fheMax(
      lhs: PromiseOrValue<BigNumberish>,
      rhs: PromiseOrValue<BigNumberish>,
      scalarByte: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    fheMin(
      lhs: PromiseOrValue<BigNumberish>,
      rhs: PromiseOrValue<BigNumberish>,
      scalarByte: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    fheMul(
      lhs: PromiseOrValue<BigNumberish>,
      rhs: PromiseOrValue<BigNumberish>,
      scalarByte: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    fheNe(
      lhs: PromiseOrValue<BigNumberish>,
      rhs: PromiseOrValue<BigNumberish>,
      scalarByte: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    fheNeg(
      ct: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    fheNot(
      ct: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    fhePubKey(
      fromLib: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<string>;

    fheRand(
      randType: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    fheRandBounded(
      upperBound: PromiseOrValue<BigNumberish>,
      randType: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    fheRem(
      lhs: PromiseOrValue<BigNumberish>,
      rhs: PromiseOrValue<BigNumberish>,
      scalarByte: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    fheRotl(
      lhs: PromiseOrValue<BigNumberish>,
      rhs: PromiseOrValue<BigNumberish>,
      scalarByte: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    fheRotr(
      lhs: PromiseOrValue<BigNumberish>,
      rhs: PromiseOrValue<BigNumberish>,
      scalarByte: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    fheShl(
      lhs: PromiseOrValue<BigNumberish>,
      rhs: PromiseOrValue<BigNumberish>,
      scalarByte: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    fheShr(
      lhs: PromiseOrValue<BigNumberish>,
      rhs: PromiseOrValue<BigNumberish>,
      scalarByte: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    fheSub(
      lhs: PromiseOrValue<BigNumberish>,
      rhs: PromiseOrValue<BigNumberish>,
      scalarByte: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    reencrypt(
      ct: PromiseOrValue<BigNumberish>,
      publicKey: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<string>;

    trivialEncrypt(
      ct: PromiseOrValue<BigNumberish>,
      toType: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    verifyCiphertext(
      input: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;
  };

  filters: {};

  estimateGas: {
    cast(
      ct: PromiseOrValue<BigNumberish>,
      toType: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    decrypt(
      ct: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    fheAdd(
      lhs: PromiseOrValue<BigNumberish>,
      rhs: PromiseOrValue<BigNumberish>,
      scalarByte: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    fheArrayEq(
      lhs: PromiseOrValue<BigNumberish>[],
      rhs: PromiseOrValue<BigNumberish>[],
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    fheBitAnd(
      lhs: PromiseOrValue<BigNumberish>,
      rhs: PromiseOrValue<BigNumberish>,
      scalarByte: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    fheBitOr(
      lhs: PromiseOrValue<BigNumberish>,
      rhs: PromiseOrValue<BigNumberish>,
      scalarByte: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    fheBitXor(
      lhs: PromiseOrValue<BigNumberish>,
      rhs: PromiseOrValue<BigNumberish>,
      scalarByte: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    fheDiv(
      lhs: PromiseOrValue<BigNumberish>,
      rhs: PromiseOrValue<BigNumberish>,
      scalarByte: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    fheEq(
      lhs: PromiseOrValue<BigNumberish>,
      rhs: PromiseOrValue<BigNumberish>,
      scalarByte: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    fheGe(
      lhs: PromiseOrValue<BigNumberish>,
      rhs: PromiseOrValue<BigNumberish>,
      scalarByte: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    fheGt(
      lhs: PromiseOrValue<BigNumberish>,
      rhs: PromiseOrValue<BigNumberish>,
      scalarByte: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    fheIfThenElse(
      control: PromiseOrValue<BigNumberish>,
      ifTrue: PromiseOrValue<BigNumberish>,
      ifFalse: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    fheLe(
      lhs: PromiseOrValue<BigNumberish>,
      rhs: PromiseOrValue<BigNumberish>,
      scalarByte: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    fheLt(
      lhs: PromiseOrValue<BigNumberish>,
      rhs: PromiseOrValue<BigNumberish>,
      scalarByte: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    fheMax(
      lhs: PromiseOrValue<BigNumberish>,
      rhs: PromiseOrValue<BigNumberish>,
      scalarByte: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    fheMin(
      lhs: PromiseOrValue<BigNumberish>,
      rhs: PromiseOrValue<BigNumberish>,
      scalarByte: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    fheMul(
      lhs: PromiseOrValue<BigNumberish>,
      rhs: PromiseOrValue<BigNumberish>,
      scalarByte: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    fheNe(
      lhs: PromiseOrValue<BigNumberish>,
      rhs: PromiseOrValue<BigNumberish>,
      scalarByte: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    fheNeg(
      ct: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    fheNot(
      ct: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    fhePubKey(
      fromLib: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    fheRand(
      randType: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    fheRandBounded(
      upperBound: PromiseOrValue<BigNumberish>,
      randType: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    fheRem(
      lhs: PromiseOrValue<BigNumberish>,
      rhs: PromiseOrValue<BigNumberish>,
      scalarByte: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    fheRotl(
      lhs: PromiseOrValue<BigNumberish>,
      rhs: PromiseOrValue<BigNumberish>,
      scalarByte: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    fheRotr(
      lhs: PromiseOrValue<BigNumberish>,
      rhs: PromiseOrValue<BigNumberish>,
      scalarByte: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    fheShl(
      lhs: PromiseOrValue<BigNumberish>,
      rhs: PromiseOrValue<BigNumberish>,
      scalarByte: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    fheShr(
      lhs: PromiseOrValue<BigNumberish>,
      rhs: PromiseOrValue<BigNumberish>,
      scalarByte: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    fheSub(
      lhs: PromiseOrValue<BigNumberish>,
      rhs: PromiseOrValue<BigNumberish>,
      scalarByte: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    reencrypt(
      ct: PromiseOrValue<BigNumberish>,
      publicKey: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    trivialEncrypt(
      ct: PromiseOrValue<BigNumberish>,
      toType: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    verifyCiphertext(
      input: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;
  };

  populateTransaction: {
    cast(
      ct: PromiseOrValue<BigNumberish>,
      toType: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    decrypt(
      ct: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    fheAdd(
      lhs: PromiseOrValue<BigNumberish>,
      rhs: PromiseOrValue<BigNumberish>,
      scalarByte: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    fheArrayEq(
      lhs: PromiseOrValue<BigNumberish>[],
      rhs: PromiseOrValue<BigNumberish>[],
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    fheBitAnd(
      lhs: PromiseOrValue<BigNumberish>,
      rhs: PromiseOrValue<BigNumberish>,
      scalarByte: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    fheBitOr(
      lhs: PromiseOrValue<BigNumberish>,
      rhs: PromiseOrValue<BigNumberish>,
      scalarByte: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    fheBitXor(
      lhs: PromiseOrValue<BigNumberish>,
      rhs: PromiseOrValue<BigNumberish>,
      scalarByte: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    fheDiv(
      lhs: PromiseOrValue<BigNumberish>,
      rhs: PromiseOrValue<BigNumberish>,
      scalarByte: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    fheEq(
      lhs: PromiseOrValue<BigNumberish>,
      rhs: PromiseOrValue<BigNumberish>,
      scalarByte: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    fheGe(
      lhs: PromiseOrValue<BigNumberish>,
      rhs: PromiseOrValue<BigNumberish>,
      scalarByte: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    fheGt(
      lhs: PromiseOrValue<BigNumberish>,
      rhs: PromiseOrValue<BigNumberish>,
      scalarByte: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    fheIfThenElse(
      control: PromiseOrValue<BigNumberish>,
      ifTrue: PromiseOrValue<BigNumberish>,
      ifFalse: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    fheLe(
      lhs: PromiseOrValue<BigNumberish>,
      rhs: PromiseOrValue<BigNumberish>,
      scalarByte: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    fheLt(
      lhs: PromiseOrValue<BigNumberish>,
      rhs: PromiseOrValue<BigNumberish>,
      scalarByte: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    fheMax(
      lhs: PromiseOrValue<BigNumberish>,
      rhs: PromiseOrValue<BigNumberish>,
      scalarByte: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    fheMin(
      lhs: PromiseOrValue<BigNumberish>,
      rhs: PromiseOrValue<BigNumberish>,
      scalarByte: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    fheMul(
      lhs: PromiseOrValue<BigNumberish>,
      rhs: PromiseOrValue<BigNumberish>,
      scalarByte: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    fheNe(
      lhs: PromiseOrValue<BigNumberish>,
      rhs: PromiseOrValue<BigNumberish>,
      scalarByte: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    fheNeg(
      ct: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    fheNot(
      ct: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    fhePubKey(
      fromLib: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    fheRand(
      randType: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    fheRandBounded(
      upperBound: PromiseOrValue<BigNumberish>,
      randType: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    fheRem(
      lhs: PromiseOrValue<BigNumberish>,
      rhs: PromiseOrValue<BigNumberish>,
      scalarByte: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    fheRotl(
      lhs: PromiseOrValue<BigNumberish>,
      rhs: PromiseOrValue<BigNumberish>,
      scalarByte: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    fheRotr(
      lhs: PromiseOrValue<BigNumberish>,
      rhs: PromiseOrValue<BigNumberish>,
      scalarByte: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    fheShl(
      lhs: PromiseOrValue<BigNumberish>,
      rhs: PromiseOrValue<BigNumberish>,
      scalarByte: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    fheShr(
      lhs: PromiseOrValue<BigNumberish>,
      rhs: PromiseOrValue<BigNumberish>,
      scalarByte: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    fheSub(
      lhs: PromiseOrValue<BigNumberish>,
      rhs: PromiseOrValue<BigNumberish>,
      scalarByte: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    reencrypt(
      ct: PromiseOrValue<BigNumberish>,
      publicKey: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    trivialEncrypt(
      ct: PromiseOrValue<BigNumberish>,
      toType: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    verifyCiphertext(
      input: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;
  };
}
